<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Orderflow — Mobile (Top-10 FAR Walls)</title>
<style>
:root{
  --bg:#061423; --card:#0e1f2b; --muted:#9fb0c8; --accent:#00d084;
  --buy:#66ffb2; --sell:#ff7b7b; --text:#e6f7ff;
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:var(--bg);color:var(--text)}
.wrap{max-width:980px;margin:8px auto;padding:10px}
.header{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap}
.title{font-size:16px;margin:0}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
select,input,button{padding:8px;border-radius:8px;border:0;background:#081726;color:var(--text);font-size:13px}
button{cursor:pointer}
.card{background:var(--card);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.45);margin-top:10px}
.row{display:flex;justify-content:space-between;align-items:center}
.small{font-size:12px;color:var(--muted)}
.grid{display:grid;grid-template-columns:1fr 340px;gap:10px;margin-top:10px}
@media (max-width:900px){ .grid{grid-template-columns:1fr} .header{flex-direction:column;align-items:flex-start} }
.trade-list{height:180px;overflow:auto;padding:6px;margin-top:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
.trade{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px;font-size:13px}
.buy{color:var(--buy)}
.sell{color:var(--sell)}
.table{font-size:13px}
.alertBox{padding:10px;border-radius:8px;margin-bottom:8px}
.swing-high{background:rgba(255,90,90,0.06);border:1px solid rgba(255,90,90,0.14);color:#ffb3b3}
.swing-low{background:rgba(0,210,130,0.04);border:1px solid rgba(0,210,130,0.12);color:#bfffe0}
.footer-note{font-size:12px;color:var(--muted);margin-top:8px}
.big{font-size:16px;font-weight:600}
.kv{font-size:13px;color:var(--muted)}
.depth-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.badge{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px}
.far-wall{display:flex;justify-content:space-between;padding:4px 6px;border-radius:6px;margin-bottom:4px;font-size:13px}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div>
      <h1 class="title">Orderflow — Mobile (Top-10 FAR Walls)</h1>
      <div class="small">Preload: 20min | FAR walls: top 10 each side</div>
    </div>
    <div class="controls">
      <label class="small">Symbol</label>
      <select id="symbol">
        <!-- Full list you gave (shortened visible names, values Binance symbols) -->
        <option>BTCUSDT</option><option>ETHUSDT</option><option>SOLUSDT</option><option>AVAXUSDT</option><option>BCHUSDT</option>
        <option>XRPUSDT</option><option>BNBUSDT</option><option>LTCUSDT</option><option>SHIBUSDT</option><option>DOTUSDT</option>
        <option>ADAUSDT</option><option>DOGEUSDT</option><option>LINKUSDT</option><option>ATOMUSDT</option><option>ALGOUSDT</option>
        <option>UNIUSDT</option><option>NEARUSDT</option><option>INJUSDT</option><option>WIFUSDT</option><option>BONKUSDT</option>
        <!-- you can add more if needed -->
      </select>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" style="display:none">Disconnect</button>
      <span id="status" class="small">Disconnected</span>
    </div>
  </div>

  <!-- top stats + swing panel -->
  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
      <div style="flex:1">
        <div id="swingPanelContainer"></div>
        <div style="display:flex;gap:10px;align-items:center;margin-top:6px;flex-wrap:wrap">
          <div class="badge"><div class="kv">Preload</div><div id="preloadStatus" class="small">Idle</div></div>
          <div class="badge"><div class="kv">Cumulative Delta</div><div id="cumlDelta" class="big">0</div></div>
          <div class="badge"><div class="kv">Buy / Sell Vol</div><div id="vols" class="big">0 / 0</div></div>
          <div class="badge"><div class="kv">Strength</div><div id="strength" class="big">—</div></div>
        </div>
      </div>
      <div style="min-width:160px;text-align:right">
        <div class="small">Tune</div>
        <div style="display:flex;gap:6px;align-items:center;justify-content:flex-end;margin-top:6px">
          <label class="small">WallSize</label><input id="wallSize" style="width:70px" value="200" />
          <label class="small">Burst</label><input id="burstCnt" style="width:70px" value="8" />
        </div>
      </div>
    </div>
  </div>

  <div class="grid">
    <!-- Left column -->
    <div>
      <div class="card">
        <div class="small">Sweep & Divergence</div>
        <div id="sweepInfo" style="margin-top:8px">SweepHigh: — | SweepLow: —</div>
        <div id="divergenceInfo" class="small" style="margin-top:4px">Divergence: —</div>
      </div>

      <div class="card">
        <div class="small">Recent Trades (live)</div>
        <div id="trades" class="trade-list"></div>
      </div>

      <div class="card">
        <div class="small">Logs</div>
        <div id="logs" style="max-height:120px;overflow:auto;margin-top:8px" class="small"></div>
      </div>
    </div>

    <!-- Right column -->
    <div>
      <div class="card">
        <div class="small">Top-of-book</div>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <div><div class="kv">Best Bid</div><div id="bestBid" class="big">-</div></div>
          <div><div class="kv">Best Ask</div><div id="bestAsk" class="big">-</div></div>
        </div>
      </div>

      <div class="card">
        <div class="small">FAR Walls (Top 10 each side)</div>
        <div style="margin-top:8px">
          <div><div class="kv">BUY (farthest)</div><div id="farBuys" style="margin-top:6px"></div></div>
          <div style="margin-top:8px"><div class="kv">SELL (farthest)</div><div id="farSells" style="margin-top:6px"></div></div>
        </div>
      </div>

      <div class="card">
        <div class="small">Controls</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="clearBtn">Clear</button>
          <button id="downloadBtn">Download L2 CSV</button>
        </div>
        <div class="footer-note">Preload: 20 minutes trades + L2 snapshot. Auto reconnect on disconnect.</div>
      </div>
    </div>
  </div>

  <!-- bottom: L2 depth full -->
  <div class="card">
    <div class="small">L2 Walls (depth snapshot / live depth20)</div>
    <div class="depth-grid" style="margin-top:8px">
      <div>
        <div class="kv">BIDS (price — qty)</div>
        <div id="buyWalls" style="max-height:260px;overflow:auto;margin-top:6px" class="table"></div>
      </div>
      <div>
        <div class="kv">ASKS (price — qty)</div>
        <div id="sellWalls" style="max-height:260px;overflow:auto;margin-top:6px" class="table"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   Mobile Orderflow — Top-10 FAR Walls (B)
   - Preload 20 minutes of trades via REST for initial delta
   - Fetch L2 snapshot (limit 1000) for long-range walls
   - Connect WS: fstream.binance.com combined stream: trade + depth20@100ms
   ========================= */

const PRELOAD_MINUTES = 20;
const FAR_WALL_COUNT = 10;         // you chose B -> top 10 far walls each side
const PRELOAD_LIMIT_TRADES = 1000; // REST trade limit (we'll fetch repeated pages if needed)
const MAX_TRADES_DISPLAY = 120;
const BURST_WINDOW_MS = 2500;
const CALIBRATION_SECONDS = 10;    // light calibration since we preload 20m

// state
let ws = null, running = false;
let symbolEl = document.getElementById('symbol');
let currentSymbol = symbolEl.value.toLowerCase();
let buyVol = 0, sellVol = 0, cumDelta = 0;
let recentTrades = []; // newest first
let bids = [], asks = [];
let lastOrderbook = null, lastPrice = null, lastPrice2 = null;
let lastHigh = null, lastLow = null, lastBestBid = null, lastBestAsk = null;
let lastDeltaSide = null;
let calibrated = false;

const statusEl = document.getElementById('status');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const tradesEl = document.getElementById('trades');
const buyWallsEl = document.getElementById('buyWalls');
const sellWallsEl = document.getElementById('sellWalls');
const bestBidEl = document.getElementById('bestBid');
const bestAskEl = document.getElementById('bestAsk');
const farBuysEl = document.getElementById('farBuys');
const farSellsEl = document.getElementById('farSells');
const cumlEl = document.getElementById('cumlDelta');
const volsEl = document.getElementById('vols');
const strengthEl = document.getElementById('strength');
const sweepInfoEl = document.getElementById('sweepInfo');
const divergenceInfoEl = document.getElementById('divergenceInfo');
const logsEl = document.getElementById('logs');
const preloadStatusEl = document.getElementById('preloadStatus');
const swingPanelContainer = document.getElementById('swingPanelContainer');

const wallSizeInput = document.getElementById('wallSize');
const burstCntInput = document.getElementById('burstCnt');

const f = v => (v === undefined || v === null) ? 0 : parseFloat(v);
const now = () => Date.now();
function log(msg){ const d = document.createElement('div'); d.innerText = `[${(new Date()).toLocaleTimeString()}] ${msg}`; logsEl.prepend(d); if(logsEl.childElementCount>300) logsEl.removeChild(logsEl.lastChild); }

// --------------- UTIL: REST helpers (Binance futures) ----------------
async function fetchJson(url){ const r = await fetch(url); if(!r.ok) throw new Error(r.status + ' ' + r.statusText); return r.json(); }

// get L2 snapshot (Binance futures REST depth; limit 1000 is max allowed)
async function fetchL2Snapshot(sym){
  // fapi depth provides aggregated depth; depth limit max depends on endpoint; depth 1000 is typical max
  const url = `https://fapi.binance.com/fapi/v1/depth?symbol=${sym.toUpperCase()}&limit=1000`;
  return await fetchJson(url);
}

// get historical trades for preload (public trades endpoint). We'll fetch in pages until we cover the last PRELOAD_MINUTES.
async function fetchRecentTrades(sym, minutesBack){
  // trades endpoint returns most recent trades; for more historical we would use aggTrades with startTime/endTime
  // We'll use /fapi/v1/aggTrades with startTime to fetch approximate 20 minutes.
  const end = Date.now();
  const start = end - minutesBack * 60 * 1000;
  const url = `https://fapi.binance.com/fapi/v1/aggTrades?symbol=${sym.toUpperCase()}&startTime=${start}&endTime=${end}&limit=1000`;
  return await fetchJson(url);
}

// compute preloaded delta from REST trades
async function preload20min(sym){
  try{
    preloadStatusEl.innerText = 'Loading (20min)...';
    const trades = await fetchRecentTrades(sym, PRELOAD_MINUTES);
    // aggTrades returns objects with q (qty) and m (maker true = taker is seller)
    buyVol = 0; sellVol = 0; cumDelta = 0;
    for(const t of trades){
      const qty = f(t.q ?? t.quantity ?? t.qty);
      const isMaker = !!t.m;
      if(isMaker){ // maker = trade maker; for Binance aggTrades, m=true means maker was buyer? historically: m=true means buyer is maker (taker sell) — but different docs; we'll use simple mapping used earlier: m=true -> maker, so taker opposite
        // treat maker true as sell (conservative mapping used earlier)
        sellVol += qty; cumDelta -= qty;
      } else {
        buyVol += qty; cumDelta += qty;
      }
      // record some for UI (limit)
      recentTrades.unshift({price:f(t.p), qty, side: isMaker ? 'sell' : 'buy', ts: (t.T || Date.now())});
      if(recentTrades.length > 2000) recentTrades.pop();
    }
    preloadStatusEl.innerText = `Preloaded ${trades.length} trades`;
    scheduleUI();
    calibrated = true;
  } catch(err){
    preloadStatusEl.innerText = 'Preload failed'; log('Preload error: ' + err.message);
  }
}

// --------------- WS handling ----------------
function makeStream(sym){
  const s = sym.toLowerCase();
  return `${s}@trade/${s}@depth20@100ms`;
}
function connectWS(){
  if(running) return;
  currentSymbol = symbolEl.value.trim().toLowerCase();
  const combined = makeStream(currentSymbol);
  const url = `wss://fstream.binance.com/stream?streams=${combined}`;
  ws = new WebSocket(url);
  statusEl.innerText = 'Connecting...';
  ws.onopen = () => {
    statusEl.innerText = 'Connected';
    running = true;
    connectBtn.style.display = 'none';
    disconnectBtn.style.display = 'inline-block';
    log('WS open: ' + currentSymbol);
    // Short calibration if not preloaded
    if(!calibrated) startCalibration();
  };
  ws.onmessage = ev => {
    try {
      const msg = JSON.parse(ev.data);
      const payload = msg.data || msg;
      if(!payload) return;
      // trade event
      if(payload.e === 'trade' || payload.e === 'aggTrade' || payload.p || payload.sale){ // accommodate formats
        // unify: price p, qty q, maker flag m
        const t = payload.e ? payload : payload;
        // Binance trade schema: p (price), q (qty), m (isBuyerMaker) for aggTrades: m boolean
        const price = f(t.p || t.price || t.P);
        const qty = f(t.q || t.quantity || t.Q);
        const isMaker = t.m === undefined ? !!t.maker : !!t.m;
        const side = isMaker ? 'sell' : 'buy';
        handleTradePayload({p:price,q:qty,m:isMaker});
      } else if(payload.b || payload.a || payload.bids || payload.asks){
        // depth update
        handleDepthPayload(payload);
      }
    } catch(e){ console.warn('ws parse', e); }
  };
  ws.onclose = () => {
    statusEl.innerText = 'Disconnected';
    running = false;
    connectBtn.style.display = 'inline-block';
    disconnectBtn.style.display = 'none';
    log('WS closed');
  };
  ws.onerror = (e) => {
    statusEl.innerText = 'WS error';
    log('WS error');
    console.error(e);
  };
}

// --------------- Depth and trade handlers ----------------
function handleDepthPayload(d){
  // payload may be {b: [...], a: [...]} or {bids:[], asks:[]}
  if(!d) return;
  if(d.b) bids = d.b.slice();
  else if(d.bids) bids = d.bids.slice();
  if(d.a) asks = d.a.slice();
  else if(d.asks) asks = d.asks.slice();

  lastOrderbook = { bids: bids.slice(), asks: asks.slice() };
  const bestB = bids.length ? f(bids[0][0]) : null;
  const bestA = asks.length ? f(asks[0][0]) : null;
  if(bestB !== null){ if(lastBestBid !== null && bestB < lastBestBid) log(`BestBid collapsed ${lastBestBid} → ${bestB}`); lastBestBid = bestB; if(lastLow === null || bestB < lastLow) lastLow = bestB; }
  if(bestA !== null){ if(lastBestAsk !== null && bestA > lastBestAsk) log(`BestAsk expanded ${lastBestAsk} → ${bestA}`); lastBestAsk = bestA; if(lastHigh === null || bestA > lastHigh) lastHigh = bestA; }
  scheduleUI();
  detectClustersAndSwing();
}

function handleTradePayload(t){
  const price = f(t.p);
  const qty = f(t.q);
  const isMaker = !!t.m;
  const side = isMaker ? 'sell' : 'buy';
  const ts = now();

  recentTrades.unshift({price, qty, side, ts});
  if(recentTrades.length > 3000) recentTrades.pop();

  if(side === 'buy'){ buyVol += qty; cumDelta += qty; } else { sellVol += qty; cumDelta -= qty; }

  lastPrice2 = lastPrice;
  lastPrice = price;

  // display trade
  const el = document.createElement('div');
  el.className = 'trade ' + (side==='buy'?'buy':'sell');
  el.innerHTML = `<div>${side.toUpperCase()} <span style="opacity:0.7">${price}</span></div><div>${qty}</div>`;
  tradesEl.prepend(el);
  while(tradesEl.childElementCount > MAX_TRADES_DISPLAY) tradesEl.removeChild(tradesEl.lastChild);

  aggregateForDivergence(price, qty, side, ts);
  detectSwing(price, cumDelta);
  scheduleUI();
}

// --------------- Aggregation for divergence (simple) ---------------
let agg1m = [], agg5m = [];
function aggregateForDivergence(price, qty, side, ts){
  const minute = Math.floor(ts / 60000) * 60000;
  const fiveMinute = Math.floor(ts / (5*60000)) * (5*60000);
  // 1m
  let b1 = agg1m.length && agg1m[agg1m.length-1].tStart === minute ? agg1m[agg1m.length-1] : null;
  if(!b1){ b1 = {tStart: minute, buyVol:0, sellVol:0, delta:0}; agg1m.push(b1); if(agg1m.length>50) agg1m.shift(); }
  if(side==='buy'){ b1.buyVol += qty; b1.delta += qty; } else { b1.sellVol += qty; b1.delta -= qty; }
  // 5m
  let b5 = agg5m.length && agg5m[agg5m.length-1].tStart === fiveMinute ? agg5m[agg5m.length-1] : null;
  if(!b5){ b5 = {tStart: fiveMinute, buyVol:0, sellVol:0, delta:0}; agg5m.push(b5); if(agg5m.length>50) agg5m.shift(); }
  if(side==='buy'){ b5.buyVol += qty; b5.delta += qty; } else { b5.sellVol += qty; b5.delta -= qty; }
}

// --------------- Detectors (clusters, sweep, divergence) ---------------
function detectClustersAndSwing(){
  const wallSize = getParamInt(wallSizeInput, 200);
  // present top portion
  const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]).slice(0,200);
  const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]).slice(0,200);

  // full L2 update bottom
  buyWallsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  sellWallsEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');

  // FAR walls: compute distance from mid/current price
  const mid = lastPrice || ((lastBestBid && lastBestAsk) ? (lastBestBid + lastBestAsk)/2 : (bidsByPrice.length?bidsByPrice[0][0]:(asksByPrice.length?asksByPrice[0][0]:0)));
  // build combined arrays with distance
  const buysWithDist = bids.map(it=>({p:f(it[0]), q:f(it[1]), dist: Math.abs(f(it[0]) - mid)}));
  const sellsWithDist = asks.map(it=>({p:f(it[0]), q:f(it[1]), dist: Math.abs(f(it[0]) - mid)}));
  const farBuys = buysWithDist.sort((a,b)=>b.dist - a.dist).slice(0, FAR_WALL_COUNT);
  const farSells = sellsWithDist.sort((a,b)=>b.dist - a.dist).slice(0, FAR_WALL_COUNT);

  farBuysEl.innerHTML = farBuys.map(w=>`<div class="far-wall"><div>${w.p}</div><div>${w.q}</div><div class="small" style="opacity:.6">d:${w.dist.toFixed(2)}</div></div>`).join('');
  farSellsEl.innerHTML = farSells.map(w=>`<div class="far-wall"><div>${w.p}</div><div>${w.q}</div><div class="small" style="opacity:.6">d:${w.dist.toFixed(2)}</div></div>`).join('');

  // clusters
  const topB = bidsByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const topA = asksByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const buyClusterCount = topB.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = topA.filter(it=>it[1] > wallSize).length;
  document.getElementById('buyCluster')?.innerText && (document.getElementById('buyCluster').innerText = buyClusterCount);
  document.getElementById('sellCluster')?.innerText && (document.getElementById('sellCluster').innerText = sellClusterCount);

  // sweep detection
  const sweepHigh = lastBestAsk !== null && lastBestAsk > (lastHigh || 0) * 0.999 && (lastHigh !== null);
  const sweepLow  = lastBestBid !== null && lastBestBid < (lastLow || Infinity) * 1.001 && (lastLow !== null);
  sweepInfoEl.innerText = `SweepHigh:${sweepHigh ? 'YES' : 'no'} | SweepLow:${sweepLow ? 'YES' : 'no'}`;

  // divergence from aggregated delta
  const divergence = detectDeltaDivergence();
  divergenceInfoEl.innerText = divergence ? (divergence === 'bear' ? 'Bear divergence' : 'Bull divergence') : '—';
}

// simple delta divergence detector
function detectDeltaDivergence(){
  if(agg1m.length < 4) return null;
  const recent = agg1m.slice(-6);
  if(recent.length < 3) return null;
  const deltas = recent.map(r => r.delta);
  const last = deltas[deltas.length-1], first = deltas[0];
  const maxD = Math.max(...deltas), minD = Math.min(...deltas);
  if(maxD > first && last < maxD * 0.8) return 'bear';
  if(minD < first && last > minD * 1.2) return 'bull';
  return null;
}

// --------------- Swing engine (2 mandatory checks + optional) ---------------
function wallShiftDetected(ob){
  if(!lastOrderbook || !ob) return false;
  const oldBuy = lastOrderbook.bids[0]?.[1] ?? 0;
  const newBuy = ob.bids[0]?.[1] ?? 0;
  const oldSell = lastOrderbook.asks[0]?.[1] ?? 0;
  const newSell = ob.asks[0]?.[1] ?? 0;
  return (newBuy > oldBuy * 1.4) || (newSell > oldSell * 1.4);
}
function fastReaction(price){
  if(!lastPrice || !lastPrice2) return false;
  return Math.abs(price - lastPrice2) > (Math.abs(lastPrice - lastPrice2) * 1.5);
}
function rateSwing(st){
  const flags = [st.sweep, st.deltaFlip, st.momentum, st.wallShift, st.reactionSpeed];
  const stars = flags.filter(v => v === 'YES').length;
  return '★'.repeat(stars) + '☆'.repeat(5 - stars);
}
function showSwingPanel(type, price, st){
  const color = type === 'HIGH' ? '#ff6666' : '#2fe08f';
  const title = type === 'HIGH' ? 'SWING HIGH' : 'SWING LOW';
  const stars = rateSwing(st);
  const el = document.createElement('div');
  el.className = 'alertBox ' + (type==='HIGH' ? 'swing-high' : 'swing-low');
  el.innerHTML = `<strong style="color:${color};font-size:15px">${title} @ ${price}</strong><br>
    • Liquidity Sweep: <b>${st.sweep}</b><br>
    • Delta Flip: <b>${st.deltaFlip}</b><br>
    • Momentum: <b>${st.momentum}</b><br>
    • Wall Shift: <b>${st.wallShift}</b><br>
    • Reaction Speed: <b>${st.reactionSpeed}</b><br>
    <hr><b>Swing Rating: ${stars}</b>`;
  swingPanelContainer.prepend(el);
  log(`${title} @ ${price} | ${stars}`);
}

// core detectSwing — called from trade handler
function detectSwing(price, delta){
  const deltaSide = delta > 0 ? 'buy' : 'sell';
  const deltaFlipToBuy = lastDeltaSide === 'sell' && deltaSide === 'buy';
  const deltaFlipToSell = lastDeltaSide === 'buy' && deltaSide === 'sell';

  const sweepHigh = (lastHigh !== null) && (price > lastHigh);
  const sweepLow  = (lastLow !== null) && (price < lastLow);

  const momentum = Math.abs(delta) > Math.max(5, Math.abs(delta) * 0.01) ; // flexible threshold
  const wallShift = wallShiftDetected(lastOrderbook);
  const reaction = fastReaction(price);

  const swingStatus = {
    sweep: (sweepHigh || sweepLow) ? 'YES' : 'NO',
    deltaFlip: (deltaFlipToBuy || deltaFlipToSell) ? 'YES' : 'NO',
    momentum: momentum ? 'YES' : 'NO',
    wallShift: wallShift ? 'YES' : 'NO',
    reactionSpeed: reaction ? 'YES' : 'NO'
  };

  // FIRE only when both mandatory conditions meet:
  if(sweepHigh && deltaFlipToSell){
    showSwingPanel('HIGH', price, swingStatus);
  }
  if(sweepLow && deltaFlipToBuy){
    showSwingPanel('LOW', price, swingStatus);
  }

  // update memory
  lastDeltaSide = deltaSide;
  if(lastHigh === null || price > lastHigh) lastHigh = price;
  if(lastLow === null || price < lastLow) lastLow = price;
}

// --------------- UI updates (throttled) ----------------
let uiTimer = null;
function scheduleUI(){ if(uiTimer) return uiTimer = setTimeout(()=>{ uiTimer = null; updateUI(); }, 120); }
function updateUI(){
  volsEl.innerText = `${buyVol.toFixed(6)} / ${sellVol.toFixed(6)}`;
  cumlEl.innerText = cumDelta.toFixed(6);
  const ratio = buyVol / Math.max(sellVol, 1);
  if(ratio > 1.6) strengthEl.innerText = 'BUYERS DOMINANT';
  else if(ratio > 1.2) strengthEl.innerText = 'Buyers Strong';
  else if(ratio < 0.6) strengthEl.innerText = 'Sellers Strong';
  else if(ratio < 0.4) strengthEl.innerText = 'SELLERS DOMINANT';
  else strengthEl.innerText = 'Balanced';

  // best bid/ask
  const bidsByPrice = bids.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
  const asksByPrice = asks.slice().map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
  bestBidEl.innerText = bidsByPrice.length ? bidsByPrice[0][0] : '-';
  bestAskEl.innerText = asksByPrice.length ? asksByPrice[0][0] : '-';
}

// --------------- Controls ---------------
document.getElementById('connectBtn').addEventListener('click', async ()=>{
  if(running) return;
  // reset state (but keep UI)
  clearAll();
  currentSymbol = symbolEl.value.trim().toLowerCase();
  statusEl.innerText = 'Preloading...';
  // preload L2 snapshot and 20m aggTrades for delta
  try{
    const [snap, trades] = await Promise.all([fetchL2Snapshot(currentSymbol), fetchRecentTrades(currentSymbol, PRELOAD_MINUTES)]);
    // set snapshot to L2 arrays
    bids = (snap.bids || snap.b).slice();
    asks = (snap.asks || snap.a).slice();
    lastOrderbook = { bids: bids.slice(), asks: asks.slice() };
    // compute mid price
    lastBestBid = bids.length ? f(bids[0][0]) : null;
    lastBestAsk = asks.length ? f(asks[0][0]) : null;
    if(lastBestBid && lastBestAsk) lastPrice = (lastBestBid + lastBestAsk)/2;

    // compute preload delta from aggTrades (same as preload20min but we have returned trades)
    buyVol = 0; sellVol = 0; cumDelta = 0;
    recentTrades = [];
    for(const t of trades){
      const qty = f(t.q ?? t.qty ?? t.quantity);
      const isMaker = !!t.m;
      const side = isMaker ? 'sell' : 'buy';
      recentTrades.push({price:f(t.p), qty, side, ts: (t.T || Date.now())});
      if(side==='buy'){ buyVol += qty; cumDelta += qty; } else { sellVol += qty; cumDelta -= qty; }
    }
    preloadStatusEl.innerText = `Preloaded ${trades.length} trades, L2 loaded`;
    scheduleUI();
  }catch(e){
    preloadStatusEl.innerText = 'Preload error';
    log('Preload error: ' + e.message);
  }

  // connect WS
  connectWS();
});

document.getElementById('disconnectBtn').addEventListener('click', ()=>{ if(ws) ws.close(); ws=null; running=false; statusEl.innerText='Disconnected'; connectBtn.style.display='inline-block'; disconnectBtn.style.display='none'; });

document.getElementById('clearBtn').addEventListener('click', clearAll);
document.getElementById('downloadBtn').addEventListener('click', ()=>{
  const rows = ['side,price,qty'];
  bids.forEach(b=>rows.push(`bid,${b[0]},${b[1]}`));
  asks.forEach(a=>rows.push(`ask,${a[0]},${a[1]}`));
  const blob = new Blob([rows.join('\n')], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=`${currentSymbol}_l2_snapshot.csv`; a.click(); URL.revokeObjectURL(url);
});

// --------------- Clear state ---------------
function clearAll(){
  buyVol=0; sellVol=0; cumDelta=0;
  recentTrades=[]; bids=[]; asks=[];
  lastBestBid=null; lastBestAsk=null;
  lastHigh=null; lastLow=null; lastPrice=null; lastPrice2=null; lastDeltaSide=null;
  lastOrderbook=null; agg1m=[]; agg5m=[];
  calibrated=false; preloadStatusEl.innerText='Idle';
  swingPanelContainer.innerHTML = '';
  tradesEl.innerHTML = '';
  buyWallsEl.innerHTML = '';
  sellWallsEl.innerHTML = '';
  farBuysEl.innerHTML = '';
  farSellsEl.innerHTML = '';
  logsEl.innerHTML = '';
  updateUI();
  log('State cleared');
}

// --------------- Calibration helper ---------------
function startCalibration(){
  let started = now();
  preloadStatusEl.innerText = 'Calibrating...';
  const iv = setInterval(()=>{
    if(now() - started > CALIBRATION_SECONDS * 1000){
      calibrated = true;
      preloadStatusEl.innerText = 'Ready';
      clearInterval(iv);
      log('Calibration complete');
    } else {
      preloadStatusEl.innerText = 'Calibrating...';
    }
  }, 800);
}

// --------------- Lightweight auto UI loop ---------------
setInterval(()=>{ scheduleUI(); }, 1000);
updateUI();
log('App ready — choose symbol and Connect.');

</script>
</body>
</html>
